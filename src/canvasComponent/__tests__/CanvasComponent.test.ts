import CanvasComponent from "../CanvasComponent";

async function _onLoadDoNothing(initData:any) {
  return initData;
}

function _onRenderDoNothing(componentState:any, context:CanvasRenderingContext2D, x:number, y:number) {
}

const fakeContext = {} as CanvasRenderingContext2D;

describe('CanvasComponent', () => {
  describe('loading', () => {
    it('is initially not loaded', () => {
      const component = new CanvasComponent(_onLoadDoNothing, _onRenderDoNothing);
      expect(component.isLoaded).toBeFalsy();
    });
    
    it('loads asynchronously', (done) => {
      const component = new CanvasComponent(_onLoadDoNothing, _onRenderDoNothing);
      component.load({}).then(() => {
        expect(component.isLoaded).toBeTruthy();
        done();
      });
    });
    
    it('component state generated by load() is available for rendering', (done) => {
      const expectedComponentState = {x:2};
      let wasOnRenderCalled = false;
      
      function onRender(componentState:any, _context:CanvasRenderingContext2D, x:number, y:number) {
        expect(componentState).toEqual(expectedComponentState);
        wasOnRenderCalled = true;
      }
      
      async function onLoad(initData:any):Promise<any> {
        return expectedComponentState;
      }
      
      const component = new CanvasComponent(onLoad, onRender);
      component.load({}).then(() => {
        component.render(fakeContext);
        expect(wasOnRenderCalled).toBeTruthy();
        done();
      });
    });
  });
  
  describe('rendering a single component', () => {
    let wasOnRenderCalled = false;
    let lastRenderX = -1, lastRenderY = -1;
    
    function onRender(componentState:any, _context:CanvasRenderingContext2D, x:number, y:number) {
      wasOnRenderCalled = true;
      lastRenderX = x;
      lastRenderY = y;
    }
    
    beforeEach(() => {
      wasOnRenderCalled = false;
      lastRenderX = -1;
      lastRenderY = -1;
    });
    
    it('render() does not call back onRender when it is not loaded', () => {
      const component = new CanvasComponent(_onLoadDoNothing, onRender);
      component.render(fakeContext);
      expect(wasOnRenderCalled).toBeFalsy();
    });

    it('renderAt() does not call back onRender when it is not loaded', () => {
      const component = new CanvasComponent(_onLoadDoNothing, onRender);
      component.renderAt(fakeContext, 5, 5);
      expect(wasOnRenderCalled).toBeFalsy();
    });

    it('render() calls back onRender when it is loaded', (done) => {
      const component = new CanvasComponent(_onLoadDoNothing, onRender);
      component.load({}).then(() => {
        component.render(fakeContext);
        expect(wasOnRenderCalled).toBeTruthy();
        done();
      });
    });

    it('render() renders to absolute coordinates based on offset when component has no parent', (done) => {
      const component = new CanvasComponent(_onLoadDoNothing, onRender);
      component.load({}).then(() => {
        component.offsetX = 5;
        component.offsetY = 7;
        component.render(fakeContext);
        expect(lastRenderX).toEqual(5);
        expect(lastRenderY).toEqual(7);
        done();
      });
    });

    it('renderAt() renders to absolute coordinates ignoring component offset', (done) => {
      const component = new CanvasComponent(_onLoadDoNothing, onRender);
      component.load({}).then(() => {
        component.offsetX = 5;
        component.offsetY = 7;
        component.renderAt(fakeContext, 1, 2);
        expect(lastRenderX).toEqual(1);
        expect(lastRenderY).toEqual(2);
        done();
      });
    });

    it('renderWithChildren() for a component with no children will call back onRender', (done) => {
      const component = new CanvasComponent(_onLoadDoNothing, onRender);
      component.load({}).then(() => {
        component.renderWithChildren(fakeContext);
        expect(wasOnRenderCalled).toBeTruthy();
        done();
      });
    });
  });

  type RenderResult = { x:number, y:number; }
  type RenderResults = {
    [componentCode:string]:RenderResult
  }
  
  describe('rendering a hierarchy of multiple component', () => {
    let renderResults:RenderResults = {};
    let componentA = new CanvasComponent(onLoad, onRender);
    let componentB = new CanvasComponent(onLoad, onRender);
    let componentC = new CanvasComponent(onLoad, onRender);
    
    function onRender(componentState:any, _context:CanvasRenderingContext2D, x:number, y:number) {
      const componentCode = componentState as string;
      renderResults[componentCode] = {x, y};
    }
    
    async function onLoad(componentCode:string):Promise<string> {
      return componentCode;
    }

    beforeEach(() => {
      componentA = new CanvasComponent(onLoad, onRender);
      componentB = new CanvasComponent(onLoad, onRender);
      componentC = new CanvasComponent(onLoad, onRender);
      renderResults = {};
      componentA.offsetX = 1; componentA.offsetY = 2;
      componentB.setParent(componentA);
      componentB.offsetX = 3; componentB.offsetY = 4;
      componentC.setParent(componentB);
      componentC.offsetX = 5; componentC.offsetY = 6;
    });
    
    it('render() renders to relative coordinates based on combined offsets of nested components', (done) => {
      componentA.load('a')
        .then(() => componentB.load('b'))
        .then(() => componentC.load('c'))
        .then(() => {
          componentC.render(fakeContext);
          const {x,y} = renderResults['c'];
          expect(x).toEqual(9);
          expect(y).toEqual(12);
          done();
        });
    });
    
    it('render() calls back onRender even if parent is not loaded', (done) => {
      componentA.load('a')
        .then(() => componentC.load('c'))
        .then(() => {
          componentC.render(fakeContext);
          const {x,y} = renderResults['c'];
          expect(x).toEqual(9);
          expect(y).toEqual(12);
          done();
        });
    });
    
    it('renderWithChildren() renders nested components that are loaded', (done) => {
      componentA.load('a')
        .then(() => componentB.load('b'))
        .then(() => componentC.load('c'))
        .then(() => {
          componentA.renderWithChildren(fakeContext);
          expect(renderResults['a']).toBeDefined();
          expect(renderResults['b']).toBeDefined();
          expect(renderResults['c']).toBeDefined();
          done();
        });
    });

    it('renderWithChildren() does not render nested components that are not loaded', (done) => {
      componentA.load('a')
        .then(() => componentC.load('c'))
        .then(() => {
          componentA.renderWithChildren(fakeContext);
          expect(renderResults['a']).toBeDefined();
          expect(renderResults['b']).not.toBeDefined();
          expect(renderResults['c']).toBeDefined();
          done();
        });
    });
  });
  
  describe('manage parent / child relationships', () => {
    it('adding a child will set its parent', () => {
      const componentA = new CanvasComponent(_onLoadDoNothing, _onRenderDoNothing);
      const componentB = new CanvasComponent(_onLoadDoNothing, _onRenderDoNothing);
      componentA.addChild(componentB);
      expect(componentB.parent).toBe(componentA);
      expect(componentA.children[0]).toBe(componentB);
    });

    it('setting a parent will add a child to the parent', () => {
      const componentA = new CanvasComponent(_onLoadDoNothing, _onRenderDoNothing);
      const componentB = new CanvasComponent(_onLoadDoNothing, _onRenderDoNothing);
      componentB.setParent(componentA);
      expect(componentB.parent).toBe(componentA);
      expect(componentA.children[0]).toBe(componentB);
    });

    it('setting a parent to null will remove a child from the parent', () => {
      const componentA = new CanvasComponent(_onLoadDoNothing, _onRenderDoNothing);
      const componentB = new CanvasComponent(_onLoadDoNothing, _onRenderDoNothing);
      componentA.addChild(componentB);
      componentB.setParent(null);
      expect(componentB.parent).toBeNull();
      expect(componentA.children.length).toEqual(0);
    });

    it('removing a child will remove it from parent', () => {
      const componentA = new CanvasComponent(_onLoadDoNothing, _onRenderDoNothing);
      const componentB = new CanvasComponent(_onLoadDoNothing, _onRenderDoNothing);
      const componentC = new CanvasComponent(_onLoadDoNothing, _onRenderDoNothing);
      componentA.addChild(componentB);
      componentA.addChild(componentC);
      componentA.removeChild(componentB);
      expect(componentB.parent).toBeNull();
      expect(componentA.children.length).toEqual(1);
    });
  });
});